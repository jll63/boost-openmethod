### rtti
```c++
struct rtti;

struct deferred_static_rtti : virtual rtti;
```

A `rtti` facet provides type information for classes and objects, implements
downcast in presence of virtual inheritance, and writes descriptions of types to
an `ostream`-like object.

`rtti` implementations are required to provide the following functions:

[cols="a,a,a", options="header"]

|===
| Name
| Description
| Required

| type_id static_type<Class>
| return a `type_id` for `Class`
| yes

| type_id dynamic_type<Class>
| return a `type_id` for an object's dynamic type
| if virtual inheritance is used

| void type_name<Stream>
| write a description of `type_id` to a stream
| no

| _unspecified_ type_index
| return a unique key for a `type_id`
| depending on context

| Derived dynamic_cast_ref<Derived, Base>
| cast from base class to derived class
| if using virtual inheritance
|===

Note:;; `Stream` is not guaranteed to be a `std::ostream`. The only guaranteed
operations are the insertion of `const char*`, `std::string_view`, `const
void*`, `std::size_t` and `type_id`.


### std_rtti

```c++
namespace boost {
namespace openmethod {
namespace policies {

struct std_rtti : virtual rtti {
    template<class Class>
    static auto static_type() -> type_id;

    template<class Class>
    static auto dynamic_type(const Class& obj) -> type_id;

    template<typename Stream>
    static auto type_name(type_id type, Stream& stream) -> void;

    static auto type_index(type_id type) -> std::type_index;

    template<typename D, typename B>
    static auto dynamic_cast_ref(B&& obj) -> D;
};

}}}
```

#### static_type

```c++
template<class Class>
static type_id static_type();
```

Return the address of `Class`'s `type_info`, cast to a `type_id`.

#### dynamic_type

```c++
template<class Class>
static type_id dynamic_type(const Class& obj);
```

Return the address of `obj`{empty}'s `type_info`, cast to a `type_id`.

#### type_name

```c++
template<typename Stream>
static void type_name(type_id type, Stream& stream);
```

Write the demangled name of the class identified by `type` to `stream`.
Execute `stream << reinterpret_cast<const std::type_info*>(type)->name()`.

#### type_index

```c++
static /*unspecified*/ type_index(type_id type);
```

Return `std::type_index(*reinterpret_cast<const std::type_info*>(type))`.

The function is required because C++ does *not* guarantee that there is a single
instance of `std::type_info` for each specific type.

#### dynamic_cast_ref

```c++
template<typename Derived, typename Base>
static Derived dynamic_cast_ref(Base&& obj);
```

Cast `obj` using the `dynamic_cast` operator.

### deferred_static_rtti

`deferred_static_rtti` makes OpenMethod defer collection of static type
information until `initialize` is called. This makes it possible to interoperate
with custom RTTI systems that use static constructors to assign type
information.

This facet is its own implementation.
