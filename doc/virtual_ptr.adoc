
[#virtual_ptr]

=== virtual_ptr


`virtual_ptr` is a fat pointer that consists of a pointer to an object, and a
pointer to its associated v-table. It is used in
`BOOST_OPENMETHOD`/`BOOST_OPENMETHOD_OVERRIDE` and `method`/`method::override`
to specify virtual parameters.

While `virtual_` is just a decorator, which is stripped when forming the
method's formal parameter list, `virtual_ptr` is a concrete type that is passed
from the method to the overrider. It should be used both in the method's
signature, and in the overrider's. For example:

```c++
BOOST_OPENMETHOD(yell, (std::ostream&, virtual_ptr<Animal>), void);

BOOST_OPENMETHOD_OVERRIDE(
    yell, (std::ostream & os, virtual_ptr<Cat> cat), void) {
    os << "hiss";
}
```

`virtual_ptr` can be passed either by value, or by const reference. Passing by
value should be preferred, unless `Type` is a smart pointer.

WARNING: calling `initialize` invalidates existing `virtual_ptr`s.

```c++
namespace boost {
namespace openmethod {

template<class Type, class Policy = BOOST_OPENMETHOD_DEFAULT_POLICY>
class virtual_ptr {
  public:
    using pointer_type = /* Type* or SmartPtr<Type> */;
    using element_type =
        std::remove_reference_t<decltype(*std::declval<pointer_type>())>;

    template<class Other>
    virtual_ptr(Other&& other);

    template<class Other>
    virtual_ptr(virtual_ptr<Other, Policy>& other);

    template<class Other>
    virtual_ptr(const virtual_ptr<Other, Policy>& other);

    template<class Other>
    virtual_ptr(virtual_ptr<Other, Policy>&& other);

    auto get() const -> pointer_type;

    auto operator->() const -> pointer_type;

    auto operator*() const -> Type&;

    template<class Other>
    static auto final(Other&& obj) -> virtual_ptr<Other, Policy>;

    template<typename Other>
    auto cast() const -> virtual_ptr<Other, Policy>;
};

template<class Type>
virtual_ptr(Type&) -> virtual_ptr<Type, BOOST_OPENMETHOD_DEFAULT_POLICY>;

template<class Class, class Policy = BOOST_OPENMETHOD_DEFAULT_POLICY>
using virtual_shared_ptr = virtual_ptr<std::shared_ptr<Class>, Policy>;

template<class Policy, class Class>
inline auto final_virtual_ptr(Class& obj);

template<class Class, class Policy = BOOST_OPENMETHOD_DEFAULT_POLICY>
inline auto make_virtual_shared() -> virtual_shared_ptr<Class, Policy>;

}}
```

*Template Parameters*

[cols="1,1"]
|===

| _Type_
| Either a class or a smart pointer to a class.


| _Policy_
| The policy.

|===

#### Type aliases

```c++
using element_type = Class;
```

```c++
using pointer_type = ...;
```

#### Constructors

```c++
template<class Other>
virtual_ptr(Other&& other);
```

Construct a `virtual_ptr` from a reference to an object. Look up and store a
pointer to the v-table for the object's dynamic type.

Requires;; `Other` must be an improper subclass of `Class`. `Policy` must
provide `dynamic_type` for `Other`.

```c++
template<class Other>
virtual_ptr(virtual_ptr<Other, Policy>& other);
```

Construct a copy of `other`.

Requires;; `Other` must be an improper subclass of `Class`.

```c++
template<class Other>
virtual_ptr(const virtual_ptr<Other, Policy>& other);
```

Requires;; `Other` must be an improper subclass of `Class`.

```c++
template<class Other>
virtual_ptr(virtual_ptr<Other, Policy>&& other);
```

Construct a copy of `other`.

Requires;; `Other` must be an improper subclass of `Class`.

```c++
template<class Other>
static auto final(Other&& obj) -> virtual_ptr<Other, Policy>;
```

Construct a `virtual_ptr` from a reference to an object. Assume that `Other` is
the object's dynamic type. Load the pointer to the v-table from
`Policy::static_vptr<Other>`.

Requires;; `Other` must be an improper subclass of `Class`.

#### Observers

```c++
auto get() const -> pointer_type;
```

Returns;; a pointer (dumb or smart) to the object.

```c++
auto operator->() const -> pointer_type;
```

Returns;; a pointer to the object.

```c++
auto operator*() const -> element_type&;
```

Returns;; a reference to the object.

```c++
template<typename Other>
auto cast() const -> virtual_ptr<Other, Policy>;
```

Returns;; a `virtual_ptr` to the same object, cast to...

Errors;; handled by facet `rtti` if `Other` is not an accessible subclass of
`Class`; `std_rtti` throws a `std::bad_cast` .

#### Deduction guide

```c++
template<class Type>
virtual_ptr(Type&) -> virtual_ptr<Type, BOOST_OPENMETHOD_DEFAULT_POLICY>;
```

#### Non-member type alias

```c++
template<class Class, class Policy = BOOST_OPENMETHOD_DEFAULT_POLICY>
using virtual_shared_ptr = virtual_ptr<std::shared_ptr<Class>, Policy>;
```

#### Non-member constructors

```c++
template<class Policy, class Class>
inline auto final_virtual_ptr(Class& obj);
```

Construct a `virtual_ptr` from a reference to an object. Assume that `Class` is
the object's dynamic type. Load the pointer to the v-table from
`Policy::static_vptr<Class>`.

```c++
template<class Class, class Policy = BOOST_OPENMETHOD_DEFAULT_POLICY>
inline auto make_virtual_shared() -> virtual_shared_ptr<Class, Policy>;
```

Construct an instance of `Class` using `std::make_shared`, and return a
`virtual_shared_ptr` to it. Load the pointer to the v-table from
`Policy::static_vptr<Class>`.
