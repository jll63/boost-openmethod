# Maximum performance with static slots and `virtual_ptr`

As described in the documentation of `generator`, static slots, in combination
with `virtual_ptr`, make open methods faster than virtual functions. This
example demonstrates how to use the feature and organize a cmake-based project.

## Project structure

The project consists of a collection of domain classes and methods, a generator
program, and an application.

The domain classes are a subset of the synopsis example (`Animal`, `Cat` and
`Dog`). They are declared in a [header](animals.hpp), along with two methods
(`poke` and `meet`). [animal.cpp](animal.cpp) contains the implementations of
the classes and methods. The Animal hierarchy also has a `poke` ordinary virtual
function, to use as a yardstick.

`animals.hpp` contains a conditional include directive:

```c++
#if __has_include("slots.hpp")
#include "slots.hpp"
#endif
```

The header is not source code, and it is not checked in the repository. It is
generated by (`generate.cpp`)[generate.cpp]:

```c++
    std::ofstream slots("slots.hpp");
    auto compiler = update();
    generator generator;

    std::ofstream slots("slots.hpp");
    generator
        .write_static_offsets<method_class(void, poke, (virtual_ptr<Animal>))>(
            slots)
        .write_static_offsets<method_class(
            void, meet, (virtual_ptr<Animal>, virtual_ptr<Animal>))>(slots);
```

The generator program also encodes the dispatch data, so the main program does
not need to call `update`:

```c++
    std::ofstream tables("tables.hpp");
    generator.encode_dispatch_data(compiler, tables);
```

`main` includes the header in its body:

```c++
int main() {
    using namespace yorel::yomm2;

    #include "tables.hpp"

    Cat felix;
    auto cat = virtual_ptr<Cat>::final(felix);
    Dog snoopy;
    virtual_ptr dog = virtual_ptr<Dog>::final(snoopy);

    // // our yardstick: an ordinary virtual function call
    // felix.poke();

    call_poke(cat);
    call_meet(dog, cat);

    return 0;
}
```

## Building

This is a possible way of integrating code generation in a `cmake` project.

First, we put all the domain classes and methods in a library:

```cmake
add_library(generator_lib OBJECT animals.cpp)
target_link_libraries(generator_lib YOMM2::yomm2)
```

We create a generator program, that depends on the library:

```cmake
add_executable(generator_gen generator_gen.cpp)
target_link_libraries(generator_gen generator_lib YOMM2::yomm2)
```

It creates the `slots.hpp` and `tables.hpp` in the current binary directory. If
these two files already exist, their content may be outdated, but it does not
matter.

Note that this works because of the `OBJECT` option for `generator_lib`.
`generator_gen` does not reference any of the domain object files. In the
absence of the `OBJECT` option, the linker would not link them, and the static
constructors that register classes, methods, and definitions would not run.

Now we must run the generator, whenever the library needs to be rebuilt, or we
change the generator itself. For this, we create a custom target that runs the
generator as a custom command, and a library that consists fo the generated
headers:

```cmake
set(GENERATED_FILES
    "${CMAKE_CURRENT_BINARY_DIR}/slots.hpp"
    "${CMAKE_CURRENT_BINARY_DIR}/tables.hpp"
)
add_custom_command(
    OUTPUT ${GENERATED_FILES}
    COMMAND generator_gen
    WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
)
add_custom_target(generator_generate DEPENDS ${GENERATED_FILES})
add_library(generator_generated_lib INTERFACE)
add_dependencies(generator_generated_lib generator_generate)
target_include_directories(generator_generated_lib INTERFACE ${CMAKE_CURRENT_BINARY_DIR})
```

Now we can build the application. Note that we add the current binary directory,
containing the generated files, to the include paths:

```cmake
add_executable(generator_app generator_app.cpp)
target_include_directories(generator_app PRIVATE ${CMAKE_CURRENT_BINARY_DIR})
target_link_libraries(generator_app PRIVATE generator_generated_lib generator_lib YOMM2::yomm2)
```

## Results

The program isolates calls to the virtual function and the methods in individual
functions, to make it easier to find the exact corresponding assembly:

A call to a virtual function:

```c++
void call_vf(Animal& a) {
    a.poke();
}
```

... translates to:

```asm
mov     rax, qword ptr [rdi]
jmp     qword ptr [rax + 16]
```

That is, two instructions, and two memory reads.

A call to a method with a single virtual argument (`poke(a)`):

```c++
void call_poke(virtual_ptr<Animal> animal) {
    poke(animal);
}
```

...translates to:

```asm
mov	rax, qword ptr [rsi + 16]
jmp	rax                             # TAILCALL
```

Also two instructions, but a single memory read. That is because the method does
not need to read the pointer to the v-table - it is passed in a `virtual_ptr`.

Finally, a call to a 2-method:

```c++
void call_meet(virtual_ptr<Animal> a1, virtual_ptr<Animal> a2) {
    meet(a1, a2);
}
```

...translates to:

```asm
mov	rax, qword ptr [rsi]
mov	r8, qword ptr [rcx + 8]
lea	r8, [r8 + 2*r8]
mov	rax, qword ptr [rax + 8*r8]
jmp	rax                             # TAILCALL
```

Achieving this with double dispatch would require _two_ virtual function calls.
